{"version":3,"sources":["../src/types/type-guards.ts","../src/constants.ts","../src/cli/options.ts","../src/utils/logging.ts","../src/utils/removePath.ts","../src/utils/sourceImages.ts","../src/utils/fileWithoutExt.ts","../node_modules/.pnpm/pathe@1.1.2/node_modules/pathe/dist/shared/pathe.ff20891b.mjs","../src/utils/getSourceOutputs.ts","../src/cache/cache.ts","../src/cache/config.ts","../src/utils/configFor.ts","../src/cli/create_cli.ts","../src/cli/info_command.ts","../src/cli/optimize_command.ts","../src/interactive/questions.ts","../src/interactive/setupConfiguration.ts","../src/cli/show_help.ts","../src/io.ts"],"sourcesContent":["import { isArray, isObject, isString } from \"inferred-types\";\nimport { InputFormat } from \"./sharp-types\";\nimport { INPUT_FILE_EXT } from \"../constants\";\nimport { ImageCache } from \"./other-types\";\nimport { command_options } from \"src/cli/options\";\nimport { Command } from \"src/cli/cli-types\";\nimport { ConfigFile } from \"./config\";\n\nexport const isInputFormat = (filepath: unknown): filepath is InputFormat => {\n  return (\n    isString(filepath) && INPUT_FILE_EXT.some((ext) => filepath.endsWith(ext))\n  );\n};\n\nexport const isImageCache = (val: unknown): val is ImageCache => {\n  return (\n    isObject(val) &&\n    \"lastUpdated\" in val &&\n    \"items\" in val &&\n    isObject(val.items)\n  );\n};\n\n/**\n * type guard which checks whether the passed in value is a known command to CLI\n */\nexport const isCommand = (val: unknown): val is Command => {\n  return isString(val) && Object.keys(command_options).includes(val as any);\n};\n\nexport const isConfigFile = (val: unknown): val is ConfigFile => {\n  return (\n    isObject(val) &&\n    \"defaults\" in val &&\n    \"sources\" in val &&\n    isObject(val.defaults) &&\n    isArray(val.sources)\n  );\n};\n","import { PerFormatOptions } from \"./types\";\n\nexport const INPUT_FILE_EXT = [\n  \"jpg\",\n  \"jpeg\",\n  \"png\",\n  \"webp\",\n  \"avif\",\n  \"gif\",\n  \"tiff\",\n] as const;\n\nexport const OUTPUT_FILE_EXT = [\n  \"jpg\",\n  \"jxl\",\n  \"png\",\n  \"webp\",\n  \"avif\",\n  \"gif\",\n  \"heif\",\n] as const;\n\nexport const CACHE_FILE = `.img-cache.json` as const;\nexport const CONFIG_FILE = `.img-config.json` as const;\n\nexport const BLURRED_SIZE = 64;\n\nexport const SHARP_DEFAULTS_FOR_IMAGE_FORMATS = {\n  jpg: {\n    chromaSubsampling: \"4:2:0\",\n    force: true,\n    mozjpeg: false,\n    optimizeCoding: true,\n    optimizeScans: false,\n    overshootDeringing: false,\n    quality: 80,\n    quantizationTable: 0,\n    trellisQuantisation: false,\n  },\n  png: {\n    adaptiveFiltering: false,\n    colors: 256,\n    compressionLevel: 6,\n    dither: 1.0,\n    effort: 7,\n    force: true,\n    palette: false,\n    quality: 100,\n  },\n  avif: {\n    bitdepth: 8,\n    chromaSubsampling: \"4:4:4\",\n    effort: 4,\n    force: true,\n    lossless: false,\n    quality: 50,\n  },\n  webp: {\n    alphaQuality: 100,\n    delay: undefined,\n    effort: 4,\n    force: true,\n    loop: 0,\n    lossless: false,\n    minSize: false,\n    mixed: false,\n    nearLossless: false,\n    preset: \"default\",\n    quality: 80,\n    smartSubsample: false,\n  },\n  jxl: {\n    decodingTier: 0,\n    distance: 1.0,\n    effort: 7,\n    force: true,\n    lossless: false,\n    quality: undefined,\n  },\n  gif: {\n    colors: 256,\n    delay: undefined,\n    dither: 1.0,\n    force: true,\n    interFrameMaxError: 0,\n    interPaletteMaxError: 3,\n    reuse: undefined,\n  },\n  heif: {\n    bitdepth: 8,\n    chromaSubsampling: \"4:4:4\",\n    compression: \"av1\",\n    effort: 4,\n    force: true,\n    lossless: false,\n    quality: 50,\n  },\n  tiff: {\n    bitdepth: 8,\n    compression: \"jpeg\",\n    force: true,\n    miniswhite: false,\n    predictor: \"horizontal\",\n    pyramid: false,\n    quality: 80,\n    resolutionUnit: \"inch\",\n    tile: false,\n    tileHeight: 256,\n    tileWidth: 256,\n    xres: 1.0,\n    yres: 1.0,\n  },\n} as const satisfies PerFormatOptions;\n","import chalk from \"chalk\";\nimport { Option } from \"./cli-types\";\n\n/** all commands receive their respective command as first param */\nconst CMD = { name: \"cmd\", type: String, defaultOption: true, multiple: false };\n\nexport const command_options = {\n  info: [\n    CMD,\n    {\n      name: \"filter\",\n      type: String,\n      alias: \"f\",\n      multiple: true,\n      typeLabel: chalk.underline(\"substr[]\"),\n      description: `only report on symbols which match filter string`,\n    },\n    {\n      name: \"clear\",\n      defaultValue: false,\n      type: Boolean,\n      description: `clear the cache and rebuild fully`,\n    },\n  ],\n  optimize: [CMD],\n} as const satisfies Record<string, Option[]>;\n\nexport const commands_union = Object.keys(command_options).join(\n  `${chalk.gray(\" | \")}`,\n);\n\n/**\n * options which are available to all commands\n */\nexport const global_options = [\n  {\n    name: \"quiet\",\n    alias: \"q\",\n    defaultValue: false,\n    type: Boolean,\n    description: `quiet stdout output to a minimum`,\n  },\n  {\n    name: \"verbose\",\n    type: Boolean,\n    alias: \"v\",\n    defaultValue: false,\n    description: `more verbose output when analyzing`,\n  },\n  {\n    name: \"help\",\n    alias: \"h\",\n    type: Boolean,\n    defaultValue: false,\n    description: `this help menu`,\n  },\n] as const satisfies Option[];\n\n/**\n * options which are available only when _no_ command is expressed\n */\nexport const only_global_options = [];\n\nexport const command_descriptions = {\n  info: `provides an overview of the various source patterns defined, how many source images there are, current state of cache, etc.`,\n  optimize: `runs the optimization over all images, leveraging the cache to avoid unnecessary work unless instructed to otherwise`,\n} as const satisfies Record<keyof typeof command_options, string>;\n","import { LogVerbosity } from \"../types/other-types\";\n\nlet verbosity: LogVerbosity = \"normal\";\n\nexport const setVerbosity = (v: LogVerbosity) => {\n  verbosity = v;\n};\n\nexport const log = (...things: unknown[]) => {\n  if (verbosity !== \"quiet\") {\n    console.log(...things);\n  }\n};\n/**\n * always log, even when user has specified `--quiet` flag\n */\nexport const shout = (...things: unknown[]) => {\n  console.log(...things);\n};\n\n/**\n * log _only_ when verbosity is set to high\n */\nexport const whisper = (...things: unknown[]) => {\n  if (verbosity === \"verbose\") {\n    console.log(...things);\n  }\n};\n","export const removePath = (filepath: string): string => {\n  const last = filepath.split(/[\\/\\\\]/).pop() as string;\n  return last;\n};\n","import { globSync } from \"fast-glob\";\n\nexport const sourceImages = (glob: string) => {\n  const files = globSync(glob);\n\n  return files;\n};\n","import { removePath } from \"./removePath\";\n\nexport const fileWithoutExt = (file: string) =>\n  removePath(file).replace(/\\.\\s*$/, \"\");\n","const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\n\nconst _UNC_REGEX = /^[/\\\\]{2}/;\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nconst _DRIVE_LETTER_RE = /^[A-Za-z]:$/;\nconst _ROOT_FOLDER_RE = /^\\/([A-Za-z]:)?$/;\nconst sep = \"/\";\nconst delimiter = \":\";\nconst normalize = function(path) {\n  if (path.length === 0) {\n    return \".\";\n  }\n  path = normalizeWindowsPath(path);\n  const isUNCPath = path.match(_UNC_REGEX);\n  const isPathAbsolute = isAbsolute(path);\n  const trailingSeparator = path[path.length - 1] === \"/\";\n  path = normalizeString(path, !isPathAbsolute);\n  if (path.length === 0) {\n    if (isPathAbsolute) {\n      return \"/\";\n    }\n    return trailingSeparator ? \"./\" : \".\";\n  }\n  if (trailingSeparator) {\n    path += \"/\";\n  }\n  if (_DRIVE_LETTER_RE.test(path)) {\n    path += \"/\";\n  }\n  if (isUNCPath) {\n    if (!isPathAbsolute) {\n      return `//./${path}`;\n    }\n    return `//${path}`;\n  }\n  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;\n};\nconst join = function(...arguments_) {\n  if (arguments_.length === 0) {\n    return \".\";\n  }\n  let joined;\n  for (const argument of arguments_) {\n    if (argument && argument.length > 0) {\n      if (joined === void 0) {\n        joined = argument;\n      } else {\n        joined += `/${argument}`;\n      }\n    }\n  }\n  if (joined === void 0) {\n    return \".\";\n  }\n  return normalize(joined.replace(/\\/\\/+/g, \"/\"));\n};\nfunction cwd() {\n  if (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n    const path = index >= 0 ? arguments_[index] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index = 0; index <= path.length; ++index) {\n    if (index < path.length) {\n      char = path[index];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p) {\n  return _IS_ABSOLUTE_RE.test(p);\n};\nconst toNamespacedPath = function(p) {\n  return normalizeWindowsPath(p);\n};\nconst _EXTNAME_RE = /.(\\.[^./]+)$/;\nconst extname = function(p) {\n  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));\n  return match && match[1] || \"\";\n};\nconst relative = function(from, to) {\n  const _from = resolve(from).replace(_ROOT_FOLDER_RE, \"$1\").split(\"/\");\n  const _to = resolve(to).replace(_ROOT_FOLDER_RE, \"$1\").split(\"/\");\n  if (_to[0][1] === \":\" && _from[0][1] === \":\" && _from[0] !== _to[0]) {\n    return _to.join(\"/\");\n  }\n  const _fromCopy = [..._from];\n  for (const segment of _fromCopy) {\n    if (_to[0] !== segment) {\n      break;\n    }\n    _from.shift();\n    _to.shift();\n  }\n  return [..._from.map(() => \"..\"), ..._to].join(\"/\");\n};\nconst dirname = function(p) {\n  const segments = normalizeWindowsPath(p).replace(/\\/$/, \"\").split(\"/\").slice(0, -1);\n  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {\n    segments[0] += \"/\";\n  }\n  return segments.join(\"/\") || (isAbsolute(p) ? \"/\" : \".\");\n};\nconst format = function(p) {\n  const segments = [p.root, p.dir, p.base ?? p.name + p.ext].filter(Boolean);\n  return normalizeWindowsPath(\n    p.root ? resolve(...segments) : segments.join(\"/\")\n  );\n};\nconst basename = function(p, extension) {\n  const lastSegment = normalizeWindowsPath(p).split(\"/\").pop();\n  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;\n};\nconst parse = function(p) {\n  const root = normalizeWindowsPath(p).split(\"/\").shift() || \"/\";\n  const base = basename(p);\n  const extension = extname(base);\n  return {\n    root,\n    dir: dirname(p),\n    base,\n    ext: extension,\n    name: base.slice(0, base.length - extension.length)\n  };\n};\n\nconst path = {\n  __proto__: null,\n  basename: basename,\n  delimiter: delimiter,\n  dirname: dirname,\n  extname: extname,\n  format: format,\n  isAbsolute: isAbsolute,\n  join: join,\n  normalize: normalize,\n  normalizeString: normalizeString,\n  parse: parse,\n  relative: relative,\n  resolve: resolve,\n  sep: sep,\n  toNamespacedPath: toNamespacedPath\n};\n\nexport { normalize as a, normalizeString as b, relative as c, delimiter as d, extname as e, dirname as f, format as g, basename as h, isAbsolute as i, join as j, parse as k, normalizeWindowsPath as n, path as p, resolve as r, sep as s, toNamespacedPath as t };\n","import { getConfigFile } from \"src/cache\";\nimport { ConfigFile, SourceConfig } from \"src/types\";\nimport { fileWithoutExt } from \"./fileWithoutExt\";\nimport { dirname, join } from \"pathe\";\nimport { existsSync, statSync } from \"fs\";\nimport { configFor } from \"./configFor\";\n\nexport type SourceFileInput = {\n  file: string;\n  outputs: Record<string, SourceOutputFile>;\n};\n\nexport type SourceOutputFile = {\n  /** the source image being optimized */\n  source: string;\n  /** the output path for the optimized image */\n  sink: string;\n  /** sink exists in filesystem */\n  exists: boolean;\n  /** the sink is newer than the source image, indicating it is fresh */\n  fresh: boolean;\n};\n\nconst produceVariants = (\n  file: string,\n  dir: string,\n  config: {\n    formats: ConfigFile[\"defaults\"][\"formats\"];\n    sizes: ConfigFile[\"defaults\"][\"sizes\"];\n    useP3: boolean;\n  },\n) => {\n  let variants: string[] = [];\n  const { formats, sizes, useP3 } = config;\n\n  // blurred image\n  variants.push(`${file}-blurred.jpg`);\n\n  for (const format of formats) {\n    const orig = `${file}-original-size.${format}`;\n    variants.push(join(dir, orig));\n\n    for (const size of sizes) {\n      const filename = `${file}-${size}.${format}`;\n      const filename_p3 = `${file}-${size}-p3.${format}`;\n      variants.push(join(dir, filename));\n      if (useP3) {\n        variants.push(join(dir, filename_p3));\n      }\n    }\n  }\n\n  return variants;\n};\n\n/**\n * Provides a list of dictionary where:\n *\n * - **keys** represent filepaths to source images\n * - **values** are an array of `SourceOutputFile` instances representing\n * the filepath to the output files produced, alons with metadata on it's\n * cache status.\n */\nexport const getSourceOutputs = (\n  source: string,\n  sourceConfig: SourceConfig,\n): SourceOutputFile[] => {\n  const config = configFor(sourceConfig);\n  const { formats, sizes, useP3 } = config;\n  const { baseFile, dirOffset, sourceStats } = config.sourceFile(source);\n\n  const outputs = produceVariants(\n    baseFile,\n    join(config.outputDirectory, dirOffset),\n    {\n      formats,\n      sizes,\n      useP3,\n    },\n  );\n\n  const withMeta = outputs.reduce((acc, key) => {\n    const exists = existsSync(key);\n    return [\n      ...acc,\n      {\n        source,\n        sink: key,\n        exists,\n        fresh: exists && statSync(key).mtimeMs > sourceStats.mtimeMs,\n      } as SourceOutputFile,\n    ];\n  }, [] as SourceOutputFile[]);\n\n  return withMeta;\n};\n","import { existsSync,  readFileSync,  statSync } from \"fs\";\nimport { CacheState, Hasher, ImageCache } from \"../types/other-types\";\nimport { CACHE_FILE } from \"../constants\";\nimport xxhash from \"xxhash-wasm\";\nimport { isImageCache } from \"../types/type-guards\";\n\n\n\nlet hasher: Hasher | null = null;\nlet cache: ImageCache | null = null;\n\nconst initializeHasher = async() => {\n  const api = await xxhash();\n  hasher = api.h32 as Hasher;\n}\n\nconst hash = (content: string, seed?: number) => {\n  if(hasher) {\n    return hasher(content, seed);\n  } else {\n    throw new Error(`call to hash() made prior to initializing the hasher!`)\n  }\n}\n\n/**\n * returns a reference to the cache as well as ensuring the\n * local variable is updated (when cache was non-present in memory\n * perviously)\n */\nconst getCache = (): ImageCache => {\n  if (cache) {\n    return cache;\n  } else {\n    if(existsSync(CACHE_FILE)) {\n      const data = readFileSync(CACHE_FILE, \"utf-8\");\n      try {\n        const json = JSON.parse(data);\n        if(isImageCache(json)) {\n          cache = json;\n          return json;\n        } else {\n          throw new Error(`the image cache appears to be malformed; try removing it and run again.`)\n        }\n\n      } catch(e) {\n        throw new Error(`problem serializing the cache file; try removing it and run again.`)\n      }\n    } else {\n      cache = {\n        lastUpdated: Date.now(),\n        items: {} // empty cache\n      };\n      return cache;\n    }\n  }\n}\n\nexport const lookupHashInCache = (filepath: string): number | null => {\n  const cache = getCache();\n\n  if (filepath in cache.items) {\n    return cache.items[filepath];\n  } else {\n    return null;\n  }\n}\n\n\n/**\n * Checks for the \"cache state\" of a given filepath:\n * \n * - `fresh`, `stale`, `missing`\n */\n\nexport const getCacheState = (filepath: string): CacheState => {\n  if(existsSync(filepath)) {\n    const cacheEntry = lookupHashInCache(filepath);\n    if(cacheEntry) {\n      const s = statSync(filepath);\n  \n      const hashContent = [\n        String(s.size),\n        String(s.blksize),\n        String(s.atime)\n      ].join(\"-\");\n\n      const current = hash(hashContent);\n      if( current === cacheEntry ) {\n        return \"fresh\";\n      } \n\n      return \"stale\";\n    }\n    \n    return \"missing\"\n\n  } else {\n    throw new Error(`source file ${filepath} does not exist!`)\n  }\n}\n","import { existsSync, readFileSync, writeFileSync } from \"fs\";\nimport { CONFIG_FILE } from \"src/constants\";\nimport { ConfigFile, isConfigFile } from \"src/types\";\nimport { log } from \"src/utils\";\n\nlet config: ConfigFile | null = null;\n\n/**\n * Test whether a configuration file is found\n */\nexport const hasConfigFile = (): boolean => {\n  return existsSync(CONFIG_FILE);\n};\n\n/**\n * Gets the configuration file if possible and throwzs an error otherwise;\n * if the operation is successful it not only returns the configuration but\n * sets the managed `config` so that other operations will be able to use it.\n */\nexport const getConfigFile = (): ConfigFile => {\n  if (hasConfigFile()) {\n    const data = readFileSync(CONFIG_FILE, \"utf8\");\n    try {\n      const c = JSON.parse(data);\n      if (isConfigFile(c)) {\n        config = c;\n        return c;\n      } else {\n        throw new Error(\n          `The configuration file at \"${CONFIG_FILE}\" appears to be damaged and can not be used.`,\n        );\n      }\n    } catch (e) {\n      throw new Error(\n        `The configuration file at \"${CONFIG_FILE}\" was not able to parsed and therefore can not be used!`,\n      );\n    }\n  } else {\n    throw new Error(\n      `Call to getConfigFile() when no configuration file exists!`,\n    );\n  }\n};\n\n/**\n * saves the configuration to file and ensures the locally managed in-memory\n * version is up-to-date.\n */\nexport const saveConfig = (cfg: ConfigFile) => {\n  writeFileSync(CONFIG_FILE, JSON.stringify(cfg), \"utf8\");\n  config = cfg;\n};\n","import { getConfigFile } from \"src/cache\";\nimport { SourceConfig } from \"src/types\";\nimport { fileWithoutExt } from \"./fileWithoutExt\";\nimport { dirname } from \"pathe\";\nimport { statSync } from \"node:fs\";\n\n/**\n * merges the configuration for a specific _source config_ with the\n * the default configuration to provide a fully qualified configuration.\n */\nexport const configFor = (source: SourceConfig) => {\n  const defaultConfig = getConfigFile().defaults;\n  const formats = source?.formats ? source.formats : defaultConfig.formats;\n  const sizes = source?.sizes ? source.sizes : defaultConfig.sizes;\n  const useP3 = source?.useP3 ? source.useP3 : defaultConfig.useP3;\n  const outputDirectory = source?.outputDirectory\n    ? source.outputDirectory\n    : defaultConfig.outputDirectory;\n\n  return {\n    /**\n     * the glob pattern used by source rule to identify source images\n     */\n    glob: source.glob,\n    /** the image formats to convert to */\n    formats,\n    /** the image sizes to convert to */\n    sizes,\n    /** whether additional images targetting P3 colorspace should be created */\n    useP3,\n    /** the base _output directory_ to put optimized images */\n    outputDirectory,\n    /**\n     * a function which will provide file based characterisics for a source image\n     * which was identified by the source rule being conveyed.\n     */\n    sourceFile: (file: string) => {\n      const baseFile = fileWithoutExt(file);\n      const dirOffset = dirname(file);\n      const sourceStats = statSync(file);\n\n      return {\n        /** the image filename without path or extension */\n        baseFile,\n        /**\n         * the directory offset coming from the source image which should be\n         * applied to the destination as an offset to the base output directory\n         */\n        dirOffset,\n        /**\n         * the file stats of the source image\n         */\n        sourceStats,\n      };\n    },\n  };\n};\n","import commandLineArgs, { CommandLineOptions } from \"command-line-args\";\nimport { Command } from \"./cli-types\";\nimport { command_options, global_options } from \"./options\";\nimport { isCommand } from \"src/types/type-guards\";\n\n/**\n * used to define CLI variable as a numeric array\n */\nexport const NumericArray = (): number[] => [];\n\nexport type CliResponse =\n  | [Command, CommandLineOptions]\n  | [undefined, CommandLineOptions];\n\nexport const create_cli = (): CliResponse => {\n  const argv = process.argv[2]?.split(\" \") || [];\n  const cmd_candidate: string = argv[0] || \"not-command\";\n\n  return isCommand(cmd_candidate)\n    ? [\n        cmd_candidate,\n        commandLineArgs(\n          [...command_options[cmd_candidate], ...global_options],\n          { stopAtFirstUnknown: true },\n        ),\n      ]\n    : [\n        undefined,\n        commandLineArgs(global_options, { stopAtFirstUnknown: true }),\n      ];\n};\n","import { getSourceOutputs, log, removePath, shout } from \"src/utils\";\nimport { AsOption } from \"./cli-types\";\nimport chalk from \"chalk\";\nimport { CONFIG_FILE } from \"src/constants\";\nimport { exit } from \"process\";\nimport { getConfigFile, hasConfigFile } from \"src/cache\";\nimport { sourceImages } from \"src/utils/sourceImages\";\nimport { isDefined } from \"inferred-types\";\n\nexport const info_command = async (_opt: AsOption<\"info\">) => {\n  log(\"info\");\n\n  if (!hasConfigFile()) {\n    shout(\"- 🙀 no configuration file found; this repo is not initialized.\");\n    shout(\n      `- run ${chalk.blue(\"io optimize\")} for an interactive configuration`,\n    );\n    shout(\n      `- alternatively you can add a config file manually at ${chalk.blue(`./${CONFIG_FILE}`)}`,\n    );\n    shout();\n    exit();\n  }\n\n  shout();\n  shout(chalk.bold(`Image Optimization: INFO`));\n  shout(chalk.bold(`------------------------`));\n  const config = getConfigFile();\n  const sources = config.sources.map((s) => ({\n    ...s,\n    sourceImages: sourceImages(s.glob),\n  }));\n  const sourceImageCount = sources.reduce(\n    (total, i) => i.sourceImages.length + total,\n    0,\n  );\n\n  shout(\n    `- you have ${chalk.bold.yellow(config.sources.length)} source(${chalk.italic.dim(\"s\")}) configured`,\n  );\n  shout(\n    `- in aggregate these source(${chalk.italic.dim(\"s\")}) identify ${chalk.bold.yellow(sourceImageCount)} source images`,\n  );\n  shout();\n  for (const source of sources) {\n    for (const img of source.sourceImages) {\n      let formats = (source.formats || config.defaults.formats)\n        .map((i) => chalk.dim(i))\n        .join(\", \");\n      let sizes = (source.sizes || config.defaults.sizes)\n        .map((i) => chalk.dim(i))\n        .join(\", \");\n      let p3 = (isDefined(source.useP3) ? source.useP3 : config.defaults.useP3)\n        ? `, P3 included`\n        : \"\";\n      let outputs = getSourceOutputs(img, source);\n      let existingOutputCount = outputs.filter((f) => f.exists);\n      let fresh = existingOutputCount.filter((f) => f.fresh);\n\n      shout(\n        chalk.bold(`- ${removePath(img)}: `) + `[${formats}] x [${sizes}]${p3}`,\n      );\n\n      shout(\n        `    - produces ${chalk.bold.yellow(outputs.length)} optimized image variants`,\n      );\n      if (existingOutputCount.length === 0) {\n        shout(`    - 😬 none of the optimized images exist currently`);\n      } else if (fresh.length === 0) {\n        shout(\n          `   - ${chalk.yellow(existingOutputCount.length)} already exist but NONE appear to be fresh 💩`,\n        );\n      } else if (fresh.length === outputs.length) {\n        shout(\n          `    - 🎉 all optimized images have been created and appear fresh`,\n        );\n      } else {\n        shout(\n          `    - ${chalk.green.bold(fresh.length)} optimized images appear to be fresh`,\n        );\n        shout(\n          `    - ${chalk.yellow(existingOutputCount.length - fresh.length)} appear to be stale and will need to be redone`,\n        );\n        shout(\n          `    - ${chalk.red(outputs.length - existingOutputCount.length)} optimized files do not yet exist`,\n        );\n      }\n    }\n  }\n};\n","import { log, shout } from \"src/utils\";\nimport { AsOption } from \"./cli-types\";\nimport { hasConfigFile } from \"src/cache\";\nimport chalk from \"chalk\";\nimport { ask } from \"@yankeeinlondon/ask\";\nimport { setupConfiguration } from \"src/interactive/setupConfiguration\";\nimport { exit } from \"process\";\n\nconst optimize = async (opt: AsOption<\"optimize\">) => {\n  //\n};\n\nexport const optimize_command = async (opt: AsOption<\"optimize\">) => {\n  if (!hasConfigFile()) {\n    shout(\n      `- 🫨 no configuration file currently exists for ${chalk.bold(\"image-opt\")}.\\n`,\n    );\n    let cont = await ask.confirm(\n      \"configure\",\n      \"Shall we interactively configure now?\",\n    )();\n    if (cont.configure) {\n      await setupConfiguration();\n      let opt = await ask.confirm(\n        \"optimize\",\n        \"Configuration is complete, shall we run optimization now?\",\n      )();\n\n      if (!opt.optimize) {\n        log();\n        exit();\n      }\n    } else {\n      log();\n      exit();\n    }\n  }\n\n  await optimize(opt);\n};\n","import { ask, survey } from \"@yankeeinlondon/ask\";\n\nexport const defaultImageFormats = ask.checkbox(\n  \"formats\",\n  \"What image format's would you like to export?\",\n  {\n    JPEG: \"jpg\",\n    GIF: \"gif\",\n    AVIF: \"avif\",\n    WebP: \"webp\",\n    HEIF: \"heif\",\n    \"JPEG XL\": \"jxl\",\n  },\n  {\n    default: [\"jpg\", \"avif\", \"webp\", \"jxl\"],\n  },\n);\n\nexport const defaultImageSizes = ask.checkbox(\n  \"sizes\",\n  \"What image sizes should be the 'default' image sizes we'll scale the source images to when optimizing? Units represent pixels and are meant to match the image width not height.\",\n  [64, 128, 256, 512, 768, 1024, 1200, 1600, 2400],\n  {\n    default: [512, 768, 1024, 1200, 1600],\n  },\n);\n\nexport const defaultMetaPolicy = ask.select(\n  \"metaPolicy\",\n  \"What would you like your default policy to be regarding metadata in source images being preserved into optimized images?\",\n  {\n    \"Remove all metadata\": \"remove\",\n    \"Keep all metadata\": \"keep\",\n    // \"Choose policy on specific properties\": \"custom\",\n  },\n  {\n    default: \"remove\",\n  },\n);\n\nexport const useP3Images = ask.confirm(\n  \"useP3\",\n  \"Do you want to produce P3 colorspaced images (in addition to sRGB images)?\",\n);\n\nexport const defaultOutputDir = ask.input(\n  \"outputDirectory\",\n  \"What should be the default output directory for optimized images?\",\n  {\n    default: \"public\",\n  },\n);\n\nexport const startWithSharpDefaults = ask.confirm(\n  \"ok\",\n  \"Are you ok to use Sharp's defaults as a starting point for your defaults?\",\n);\n\nexport const sourceGlob = ask.input(\n  \"glob\",\n  \"Each 'source rule' in your configuration will have a 'glob pattern' to identify the files it includes as source images. You need at least one rule to have Image Opt make any optimizations so let's setup that glob patterns now.\",\n  {\n    default: \"design-assets/**/*.{jpg,png,tiff}\",\n  },\n);\n\nexport const confirmNoOverrides = ask.confirm(\n  \"noOverrides\",\n  \"Can we keep your default configuration for this source for now?\",\n);\n\nexport const sourceFormats = ask\n  .withRequirements({ formats: \"Array<string(jpg,gif,avif,webp,heif,jxl)>\" })\n  .checkbox(\n    \"sourceFormats\",\n    \"What image format's would you like to export for this rule (your default chosen earlier is the default for now):\",\n    {\n      JPEG: \"jpg\",\n      GIF: \"gif\",\n      AVIF: \"avif\",\n      WebP: \"webp\",\n      HEIF: \"heif\",\n      \"JPEG XL\": \"jxl\",\n    },\n    {\n      default: (a) => a.formats,\n    },\n  );\n\nexport const sourceImageSizes = ask\n  .withRequirements({\n    sizes: \"Array<number(64,128,256,768,1024,1200,1600,2400)>\",\n  })\n  .checkbox(\n    \"sourceSize\",\n    \"What optimized image sizes should be produced for this rule?\",\n    [64, 128, 256, 512, 768, 1024, 1200, 1600, 2400],\n    {\n      default: (a) => a.sizes,\n    },\n  );\n\nexport const sourceMetaPolicy = ask\n  .withRequirements({ defaultMetaPolicy: \"string(remove,keep,custom)\" })\n  .select(\n    \"sourceMetaPolicy\",\n    \"What metadata policy should we use when producing opimized image using this source rule??\",\n    {\n      \"Remove all metadata\": \"remove\",\n      \"Keep all metadata\": \"keep\",\n      \"Choose policy on specific properties\": \"custom\",\n    },\n    {\n      default: (a) => a.defaultMetaPolicy,\n    },\n  );\n\n/**\n * Asks the user for all \"core\" defaults before asking if other defaults are ok to keep\n * in line with what Sharp provides.\n */\nexport const getCoreDefaults = survey(\n  defaultImageFormats,\n  defaultImageSizes,\n  defaultMetaPolicy,\n  useP3Images,\n  defaultOutputDir,\n);\n\nexport const getSourceGlobAndConfirmNoOverrides = survey(\n  sourceGlob,\n  confirmNoOverrides,\n);\n","import { shout } from \"src/utils\";\nimport {\n  getCoreDefaults,\n  getSourceGlobAndConfirmNoOverrides,\n  startWithSharpDefaults,\n} from \"./questions\";\nimport chalk from \"chalk\";\nimport { ConfigFile } from \"src/types\";\nimport { CONFIG_FILE, SHARP_DEFAULTS_FOR_IMAGE_FORMATS } from \"src/constants\";\nimport { saveConfig } from \"src/cache/config\";\n\nexport const setupConfiguration = async () => {\n  shout(chalk.bold`\\nInteractive Configuration Setup`);\n  shout(chalk.bold`-------------------------------\\n`);\n  shout(`First step is to setup your \"defaults\" for:`);\n  shout(`  - image ${chalk.italic(\"formats\")}.`);\n  shout(`  - image ${chalk.italic(\"sizes\")}.`);\n  shout(`  - image ${chalk.italic(\"meta data\")}.`);\n  shout(\n    `  - image ${chalk.italic(\"conversion to\")} ${chalk.bold(\"P3\")} (in addition to ${chalk.bold(\"sRGB\")})`,\n  );\n  shout();\n  const defaultValues: ConfigFile[\"defaults\"] = await getCoreDefaults.start({\n    perFormatOptions: {},\n    useInterlaced: true,\n    density: 300,\n  });\n\n  shout(`\\n\\nGreat! we've got a lot of the important defaults set now.\\n`);\n  shout(\n    `- when we convert/optimize images we use the fantastic ${chalk.bold.blue(\"Sharp\")} library`,\n  );\n  shout(\n    `- it is super fast and has really good \"defaults\" for each output image format`,\n  );\n  shout(\n    `- in 99% of cases we recommend you start with these defaults as ${chalk.italic(\"your\")} starting point`,\n  );\n  shout(\n    `- if you agree to this as a starting point, we'll add ${chalk.italic(\"explicit\")} references to these defaults`,\n  );\n  shout(\n    `  in your configuration file so you can more clearly understand the settings and modify it later.`,\n  );\n  shout();\n\n  const ok = (await startWithSharpDefaults()).ok;\n\n  if (ok) {\n    defaultValues.perFormatOptions = SHARP_DEFAULTS_FOR_IMAGE_FORMATS;\n  }\n\n  shout();\n  shout(chalk.bold(`Source Rules`));\n  shout(chalk.bold(`------------`));\n  shout();\n  shout(\n    `We are now done with default values but we must have at least one SOURCE configuration`,\n  );\n  shout(\n    `- a ${chalk.italic(\"source configuration\")} is responsible for two things:`,\n  );\n  shout();\n  shout(\n    `  1. it must always specify the ${chalk.bold(\"source files\")} with a ${chalk.italic(\"glob expression\")}.`,\n  );\n  shout(\n    `  2. it optionaly can ${chalk.italic(`override`)} any of the defaults which were setup`,\n  );\n  shout();\n\n  const source = await getSourceGlobAndConfirmNoOverrides.start();\n\n  if (source.noOverrides) {\n    saveConfig({ defaults: defaultValues, sources: [{ glob: source.glob }] });\n  }\n\n  shout();\n  shout(chalk.bold(`🚀 Configured!!!!`));\n  shout(chalk.bold(`-----------------`));\n  shout();\n  shout(\n    `- you can review and/or modify your configuration at ${chalk.blue(CONFIG_FILE)} whenever you like`,\n  );\n};\n","import commandLineUsage from \"command-line-usage\";\nimport { Command } from \"./cli-types\";\nimport { isCommand } from \"src/types\";\nimport chalk from \"chalk\";\nimport {\n  command_descriptions,\n  command_options,\n  commands_union,\n  global_options,\n} from \"./options\";\n\nexport const sections = (cmd?: string) => [\n  {\n    header: \"Image Opt\",\n    content: \"Prepare your source images for the web.\",\n  },\n  {\n    header: `Syntax`,\n    content: isCommand(cmd)\n      ? `${chalk.bold(\"io\")} ${cmd} ${chalk.dim(`[ ${chalk.italic(\"options\")} ]`)}\\n\\n${command_descriptions[cmd] || \"\"}`\n      : `${chalk.bold(\"io\")} [ ${chalk.dim(commands_union)} ] ${chalk.dim(`[ ${chalk.italic(\"options\")} ]`)}\n\n      Choose a command from those listed above and add ${chalk.bold(\"--help\")} for\n      more info.`,\n  },\n  isCommand(cmd)\n    ? {}\n    : {\n        header: \"Commands:\",\n        content: Object.keys(command_descriptions)\n          .map((k) => {\n            const desc = command_descriptions[\n              k as keyof typeof command_descriptions\n            ] as string;\n            return `${chalk.bold(k)}: ${chalk.dim(desc)}`;\n          })\n          .join(\"\\n\"),\n      },\n  {\n    header: isCommand(cmd) ? \"Options\" : \"Global Options\",\n    optionList: isCommand(cmd)\n      ? [\n          ...command_options[cmd].filter((i) => i.name !== \"cmd\"),\n          ...global_options,\n        ]\n      : global_options,\n  },\n];\n\nexport const show_help = (cmd?: Command | undefined) => {\n  const usage = commandLineUsage(sections(cmd));\n  console.log(usage);\n};\n","import { isCommand } from \"src/types\";\n\nimport { setVerbosity } from \"src/utils\";\nimport {\n  AsOption,\n  create_cli,\n  info_command,\n  optimize_command,\n  show_help,\n} from \"./cli\";\n\nconst [cmd, cli] = create_cli();\n\nif (!cmd) {\n  show_help();\n  if (cli.help) {\n    process.exit(0);\n  } else {\n    process.exit(1);\n  }\n} else {\n  if (cli.help) {\n    show_help(cmd);\n    process.exit(0);\n  } else {\n    if (isCommand(cmd)) {\n      const opt = cli as AsOption<null>;\n      setVerbosity(opt.quiet ? \"quiet\" : opt.verbose ? \"verbose\" : \"normal\");\n      switch (cmd) {\n        case \"info\":\n          await info_command(cli as AsOption<\"info\">);\n          break;\n        case \"optimize\":\n          await optimize_command(cli as AsOption<\"optimize\">);\n          break;\n      }\n    }\n  }\n}\n"],"mappings":";AAAA,SAAS,SAAS,UAAU,gBAAgB;;;ACuBrC,IAAM,cAAc;AAIpB,IAAM,mCAAmC;AAAA,EAC9C,KAAK;AAAA,IACH,mBAAmB;AAAA,IACnB,OAAO;AAAA,IACP,SAAS;AAAA,IACT,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,SAAS;AAAA,IACT,mBAAmB;AAAA,IACnB,qBAAqB;AAAA,EACvB;AAAA,EACA,KAAK;AAAA,IACH,mBAAmB;AAAA,IACnB,QAAQ;AAAA,IACR,kBAAkB;AAAA,IAClB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,SAAS;AAAA,IACT,SAAS;AAAA,EACX;AAAA,EACA,MAAM;AAAA,IACJ,UAAU;AAAA,IACV,mBAAmB;AAAA,IACnB,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,MAAM;AAAA,IACJ,cAAc;AAAA,IACd,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,IACV,SAAS;AAAA,IACT,OAAO;AAAA,IACP,cAAc;AAAA,IACd,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,gBAAgB;AAAA,EAClB;AAAA,EACA,KAAK;AAAA,IACH,cAAc;AAAA,IACd,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,KAAK;AAAA,IACH,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,oBAAoB;AAAA,IACpB,sBAAsB;AAAA,IACtB,OAAO;AAAA,EACT;AAAA,EACA,MAAM;AAAA,IACJ,UAAU;AAAA,IACV,mBAAmB;AAAA,IACnB,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,MAAM;AAAA,IACJ,UAAU;AAAA,IACV,aAAa;AAAA,IACb,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,SAAS;AAAA,IACT,SAAS;AAAA,IACT,gBAAgB;AAAA,IAChB,MAAM;AAAA,IACN,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AACF;;;AChHA,OAAO,WAAW;AAIlB,IAAM,MAAM,EAAE,MAAM,OAAO,MAAM,QAAQ,eAAe,MAAM,UAAU,MAAM;AAEvE,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,IACJ;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,MACP,UAAU;AAAA,MACV,WAAW,MAAM,UAAU,UAAU;AAAA,MACrC,aAAa;AAAA,IACf;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,cAAc;AAAA,MACd,MAAM;AAAA,MACN,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EACA,UAAU,CAAC,GAAG;AAChB;AAEO,IAAM,iBAAiB,OAAO,KAAK,eAAe,EAAE;AAAA,EACzD,GAAG,MAAM,KAAK,KAAK,CAAC;AACtB;AAKO,IAAM,iBAAiB;AAAA,EAC5B;AAAA,IACE,MAAM;AAAA,IACN,OAAO;AAAA,IACP,cAAc;AAAA,IACd,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,cAAc;AAAA,IACd,aAAa;AAAA,EACf;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,cAAc;AAAA,IACd,aAAa;AAAA,EACf;AACF;AAOO,IAAM,uBAAuB;AAAA,EAClC,MAAM;AAAA,EACN,UAAU;AACZ;;;AFxCO,IAAM,YAAY,CAAC,QAAiC;AACzD,SAAO,SAAS,GAAG,KAAK,OAAO,KAAK,eAAe,EAAE,SAAS,GAAU;AAC1E;AAEO,IAAM,eAAe,CAAC,QAAoC;AAC/D,SACE,SAAS,GAAG,KACZ,cAAc,OACd,aAAa,OACb,SAAS,IAAI,QAAQ,KACrB,QAAQ,IAAI,OAAO;AAEvB;;;AGpCA,IAAI,YAA0B;AAEvB,IAAM,eAAe,CAAC,MAAoB;AAC/C,cAAY;AACd;AAEO,IAAM,MAAM,IAAI,WAAsB;AAC3C,MAAI,cAAc,SAAS;AACzB,YAAQ,IAAI,GAAG,MAAM;AAAA,EACvB;AACF;AAIO,IAAM,QAAQ,IAAI,WAAsB;AAC7C,UAAQ,IAAI,GAAG,MAAM;AACvB;;;AClBO,IAAM,aAAa,CAAC,aAA6B;AACtD,QAAM,OAAO,SAAS,MAAM,QAAQ,EAAE,IAAI;AAC1C,SAAO;AACT;;;ACHA,SAAS,gBAAgB;AAElB,IAAM,eAAe,CAAC,SAAiB;AAC5C,QAAM,QAAQ,SAAS,IAAI;AAE3B,SAAO;AACT;;;ACJO,IAAM,iBAAiB,CAAC,SAC7B,WAAW,IAAI,EAAE,QAAQ,UAAU,EAAE;;;ACHvC,IAAM,yBAAyB;AAC/B,SAAS,qBAAqB,QAAQ,IAAI;AACxC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AACA,SAAO,MAAM,QAAQ,OAAO,GAAG,EAAE,QAAQ,wBAAwB,CAAC,MAAM,EAAE,YAAY,CAAC;AACzF;AAEA,IAAM,aAAa;AACnB,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AAIzB,IAAM,YAAY,SAASA,OAAM;AAC/B,MAAIA,MAAK,WAAW,GAAG;AACrB,WAAO;AAAA,EACT;AACA,EAAAA,QAAO,qBAAqBA,KAAI;AAChC,QAAM,YAAYA,MAAK,MAAM,UAAU;AACvC,QAAM,iBAAiB,WAAWA,KAAI;AACtC,QAAM,oBAAoBA,MAAKA,MAAK,SAAS,CAAC,MAAM;AACpD,EAAAA,QAAO,gBAAgBA,OAAM,CAAC,cAAc;AAC5C,MAAIA,MAAK,WAAW,GAAG;AACrB,QAAI,gBAAgB;AAClB,aAAO;AAAA,IACT;AACA,WAAO,oBAAoB,OAAO;AAAA,EACpC;AACA,MAAI,mBAAmB;AACrB,IAAAA,SAAQ;AAAA,EACV;AACA,MAAI,iBAAiB,KAAKA,KAAI,GAAG;AAC/B,IAAAA,SAAQ;AAAA,EACV;AACA,MAAI,WAAW;AACb,QAAI,CAAC,gBAAgB;AACnB,aAAO,OAAOA,KAAI;AAAA,IACpB;AACA,WAAO,KAAKA,KAAI;AAAA,EAClB;AACA,SAAO,kBAAkB,CAAC,WAAWA,KAAI,IAAI,IAAIA,KAAI,KAAKA;AAC5D;AACA,IAAM,OAAO,YAAY,YAAY;AACnC,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT;AACA,MAAI;AACJ,aAAW,YAAY,YAAY;AACjC,QAAI,YAAY,SAAS,SAAS,GAAG;AACnC,UAAI,WAAW,QAAQ;AACrB,iBAAS;AAAA,MACX,OAAO;AACL,kBAAU,IAAI,QAAQ;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AACA,MAAI,WAAW,QAAQ;AACrB,WAAO;AAAA,EACT;AACA,SAAO,UAAU,OAAO,QAAQ,UAAU,GAAG,CAAC;AAChD;AAyBA,SAAS,gBAAgBC,OAAM,gBAAgB;AAC7C,MAAI,MAAM;AACV,MAAI,oBAAoB;AACxB,MAAI,YAAY;AAChB,MAAI,OAAO;AACX,MAAI,OAAO;AACX,WAAS,QAAQ,GAAG,SAASA,MAAK,QAAQ,EAAE,OAAO;AACjD,QAAI,QAAQA,MAAK,QAAQ;AACvB,aAAOA,MAAK,KAAK;AAAA,IACnB,WAAW,SAAS,KAAK;AACvB;AAAA,IACF,OAAO;AACL,aAAO;AAAA,IACT;AACA,QAAI,SAAS,KAAK;AAChB,UAAI,cAAc,QAAQ,KAAK,SAAS,EAAG;AAAA,eAAW,SAAS,GAAG;AAChE,YAAI,IAAI,SAAS,KAAK,sBAAsB,KAAK,IAAI,IAAI,SAAS,CAAC,MAAM,OAAO,IAAI,IAAI,SAAS,CAAC,MAAM,KAAK;AAC3G,cAAI,IAAI,SAAS,GAAG;AAClB,kBAAM,iBAAiB,IAAI,YAAY,GAAG;AAC1C,gBAAI,mBAAmB,IAAI;AACzB,oBAAM;AACN,kCAAoB;AAAA,YACtB,OAAO;AACL,oBAAM,IAAI,MAAM,GAAG,cAAc;AACjC,kCAAoB,IAAI,SAAS,IAAI,IAAI,YAAY,GAAG;AAAA,YAC1D;AACA,wBAAY;AACZ,mBAAO;AACP;AAAA,UACF,WAAW,IAAI,SAAS,GAAG;AACzB,kBAAM;AACN,gCAAoB;AACpB,wBAAY;AACZ,mBAAO;AACP;AAAA,UACF;AAAA,QACF;AACA,YAAI,gBAAgB;AAClB,iBAAO,IAAI,SAAS,IAAI,QAAQ;AAChC,8BAAoB;AAAA,QACtB;AAAA,MACF,OAAO;AACL,YAAI,IAAI,SAAS,GAAG;AAClB,iBAAO,IAAIA,MAAK,MAAM,YAAY,GAAG,KAAK,CAAC;AAAA,QAC7C,OAAO;AACL,gBAAMA,MAAK,MAAM,YAAY,GAAG,KAAK;AAAA,QACvC;AACA,4BAAoB,QAAQ,YAAY;AAAA,MAC1C;AACA,kBAAY;AACZ,aAAO;AAAA,IACT,WAAW,SAAS,OAAO,SAAS,IAAI;AACtC,QAAE;AAAA,IACJ,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAM,aAAa,SAAS,GAAG;AAC7B,SAAO,gBAAgB,KAAK,CAAC;AAC/B;AAyBA,IAAM,UAAU,SAAS,GAAG;AAC1B,QAAM,WAAW,qBAAqB,CAAC,EAAE,QAAQ,OAAO,EAAE,EAAE,MAAM,GAAG,EAAE,MAAM,GAAG,EAAE;AAClF,MAAI,SAAS,WAAW,KAAK,iBAAiB,KAAK,SAAS,CAAC,CAAC,GAAG;AAC/D,aAAS,CAAC,KAAK;AAAA,EACjB;AACA,SAAO,SAAS,KAAK,GAAG,MAAM,WAAW,CAAC,IAAI,MAAM;AACtD;;;AC9KA,SAAS,cAAAC,aAAY,YAAAC,iBAAgB;;;ACDrC,OAAO,YAAY;;;ACHnB,SAAS,YAAY,cAAc,qBAAqB;AAKxD,IAAI,SAA4B;AAKzB,IAAM,gBAAgB,MAAe;AAC1C,SAAO,WAAW,WAAW;AAC/B;AAOO,IAAM,gBAAgB,MAAkB;AAC7C,MAAI,cAAc,GAAG;AACnB,UAAM,OAAO,aAAa,aAAa,MAAM;AAC7C,QAAI;AACF,YAAM,IAAI,KAAK,MAAM,IAAI;AACzB,UAAI,aAAa,CAAC,GAAG;AACnB,iBAAS;AACT,eAAO;AAAA,MACT,OAAO;AACL,cAAM,IAAI;AAAA,UACR,8BAA8B,WAAW;AAAA,QAC3C;AAAA,MACF;AAAA,IACF,SAAS,GAAG;AACV,YAAM,IAAI;AAAA,QACR,8BAA8B,WAAW;AAAA,MAC3C;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AAMO,IAAM,aAAa,CAAC,QAAoB;AAC7C,gBAAc,aAAa,KAAK,UAAU,GAAG,GAAG,MAAM;AACtD,WAAS;AACX;;;AC/CA,SAAS,gBAAgB;AAMlB,IAAM,YAAY,CAAC,WAAyB;AACjD,QAAM,gBAAgB,cAAc,EAAE;AACtC,QAAM,UAAU,QAAQ,UAAU,OAAO,UAAU,cAAc;AACjE,QAAM,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,cAAc;AAC3D,QAAM,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,cAAc;AAC3D,QAAM,kBAAkB,QAAQ,kBAC5B,OAAO,kBACP,cAAc;AAElB,SAAO;AAAA;AAAA;AAAA;AAAA,IAIL,MAAM,OAAO;AAAA;AAAA,IAEb;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,YAAY,CAAC,SAAiB;AAC5B,YAAM,WAAW,eAAe,IAAI;AACpC,YAAM,YAAY,QAAQ,IAAI;AAC9B,YAAM,cAAc,SAAS,IAAI;AAEjC,aAAO;AAAA;AAAA,QAEL;AAAA;AAAA;AAAA;AAAA;AAAA,QAKA;AAAA;AAAA;AAAA;AAAA,QAIA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AHjCA,IAAM,kBAAkB,CACtB,MACA,KACAC,YAKG;AACH,MAAI,WAAqB,CAAC;AAC1B,QAAM,EAAE,SAAS,OAAO,MAAM,IAAIA;AAGlC,WAAS,KAAK,GAAG,IAAI,cAAc;AAEnC,aAAWC,WAAU,SAAS;AAC5B,UAAM,OAAO,GAAG,IAAI,kBAAkBA,OAAM;AAC5C,aAAS,KAAK,KAAK,KAAK,IAAI,CAAC;AAE7B,eAAW,QAAQ,OAAO;AACxB,YAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAIA,OAAM;AAC1C,YAAM,cAAc,GAAG,IAAI,IAAI,IAAI,OAAOA,OAAM;AAChD,eAAS,KAAK,KAAK,KAAK,QAAQ,CAAC;AACjC,UAAI,OAAO;AACT,iBAAS,KAAK,KAAK,KAAK,WAAW,CAAC;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAUO,IAAM,mBAAmB,CAC9B,QACA,iBACuB;AACvB,QAAMD,UAAS,UAAU,YAAY;AACrC,QAAM,EAAE,SAAS,OAAO,MAAM,IAAIA;AAClC,QAAM,EAAE,UAAU,WAAW,YAAY,IAAIA,QAAO,WAAW,MAAM;AAErE,QAAM,UAAU;AAAA,IACd;AAAA,IACA,KAAKA,QAAO,iBAAiB,SAAS;AAAA,IACtC;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAW,QAAQ,OAAO,CAAC,KAAK,QAAQ;AAC5C,UAAM,SAASE,YAAW,GAAG;AAC7B,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA,OAAO,UAAUC,UAAS,GAAG,EAAE,UAAU,YAAY;AAAA,MACvD;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAuB;AAE3B,SAAO;AACT;;;AI/FA,OAAO,qBAA6C;AAc7C,IAAM,aAAa,MAAmB;AAC3C,QAAM,OAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC;AAC7C,QAAM,gBAAwB,KAAK,CAAC,KAAK;AAEzC,SAAO,UAAU,aAAa,IAC1B;AAAA,IACE;AAAA,IACA;AAAA,MACE,CAAC,GAAG,gBAAgB,aAAa,GAAG,GAAG,cAAc;AAAA,MACrD,EAAE,oBAAoB,KAAK;AAAA,IAC7B;AAAA,EACF,IACA;AAAA,IACE;AAAA,IACA,gBAAgB,gBAAgB,EAAE,oBAAoB,KAAK,CAAC;AAAA,EAC9D;AACN;;;AC5BA,OAAOC,YAAW;AAElB,SAAS,YAAY;AAGrB,SAAS,iBAAiB;AAEnB,IAAM,eAAe,OAAO,SAA2B;AAC5D,MAAI,MAAM;AAEV,MAAI,CAAC,cAAc,GAAG;AACpB,UAAM,wEAAiE;AACvE;AAAA,MACE,SAASC,OAAM,KAAK,aAAa,CAAC;AAAA,IACpC;AACA;AAAA,MACE,yDAAyDA,OAAM,KAAK,KAAK,WAAW,EAAE,CAAC;AAAA,IACzF;AACA,UAAM;AACN,SAAK;AAAA,EACP;AAEA,QAAM;AACN,QAAMA,OAAM,KAAK,0BAA0B,CAAC;AAC5C,QAAMA,OAAM,KAAK,0BAA0B,CAAC;AAC5C,QAAMC,UAAS,cAAc;AAC7B,QAAM,UAAUA,QAAO,QAAQ,IAAI,CAAC,OAAO;AAAA,IACzC,GAAG;AAAA,IACH,cAAc,aAAa,EAAE,IAAI;AAAA,EACnC,EAAE;AACF,QAAM,mBAAmB,QAAQ;AAAA,IAC/B,CAAC,OAAO,MAAM,EAAE,aAAa,SAAS;AAAA,IACtC;AAAA,EACF;AAEA;AAAA,IACE,cAAcD,OAAM,KAAK,OAAOC,QAAO,QAAQ,MAAM,CAAC,WAAWD,OAAM,OAAO,IAAI,GAAG,CAAC;AAAA,EACxF;AACA;AAAA,IACE,+BAA+BA,OAAM,OAAO,IAAI,GAAG,CAAC,cAAcA,OAAM,KAAK,OAAO,gBAAgB,CAAC;AAAA,EACvG;AACA,QAAM;AACN,aAAW,UAAU,SAAS;AAC5B,eAAW,OAAO,OAAO,cAAc;AACrC,UAAI,WAAW,OAAO,WAAWC,QAAO,SAAS,SAC9C,IAAI,CAAC,MAAMD,OAAM,IAAI,CAAC,CAAC,EACvB,KAAK,IAAI;AACZ,UAAI,SAAS,OAAO,SAASC,QAAO,SAAS,OAC1C,IAAI,CAAC,MAAMD,OAAM,IAAI,CAAC,CAAC,EACvB,KAAK,IAAI;AACZ,UAAI,MAAM,UAAU,OAAO,KAAK,IAAI,OAAO,QAAQC,QAAO,SAAS,SAC/D,kBACA;AACJ,UAAI,UAAU,iBAAiB,KAAK,MAAM;AAC1C,UAAI,sBAAsB,QAAQ,OAAO,CAAC,MAAM,EAAE,MAAM;AACxD,UAAI,QAAQ,oBAAoB,OAAO,CAAC,MAAM,EAAE,KAAK;AAErD;AAAA,QACED,OAAM,KAAK,KAAK,WAAW,GAAG,CAAC,IAAI,IAAI,IAAI,OAAO,QAAQ,KAAK,IAAI,EAAE;AAAA,MACvE;AAEA;AAAA,QACE,kBAAkBA,OAAM,KAAK,OAAO,QAAQ,MAAM,CAAC;AAAA,MACrD;AACA,UAAI,oBAAoB,WAAW,GAAG;AACpC,cAAM,8DAAuD;AAAA,MAC/D,WAAW,MAAM,WAAW,GAAG;AAC7B;AAAA,UACE,QAAQA,OAAM,OAAO,oBAAoB,MAAM,CAAC;AAAA,QAClD;AAAA,MACF,WAAW,MAAM,WAAW,QAAQ,QAAQ;AAC1C;AAAA,UACE;AAAA,QACF;AAAA,MACF,OAAO;AACL;AAAA,UACE,SAASA,OAAM,MAAM,KAAK,MAAM,MAAM,CAAC;AAAA,QACzC;AACA;AAAA,UACE,SAASA,OAAM,OAAO,oBAAoB,SAAS,MAAM,MAAM,CAAC;AAAA,QAClE;AACA;AAAA,UACE,SAASA,OAAM,IAAI,QAAQ,SAAS,oBAAoB,MAAM,CAAC;AAAA,QACjE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;ACtFA,OAAOE,YAAW;AAClB,SAAS,OAAAC,YAAW;;;ACJpB,SAAS,KAAK,cAAc;AAErB,IAAM,sBAAsB,IAAI;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,EACb;AAAA,EACA;AAAA,IACE,SAAS,CAAC,OAAO,QAAQ,QAAQ,KAAK;AAAA,EACxC;AACF;AAEO,IAAM,oBAAoB,IAAI;AAAA,EACnC;AAAA,EACA;AAAA,EACA,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,MAAM,MAAM,MAAM,IAAI;AAAA,EAC/C;AAAA,IACE,SAAS,CAAC,KAAK,KAAK,MAAM,MAAM,IAAI;AAAA,EACtC;AACF;AAEO,IAAM,oBAAoB,IAAI;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,IACE,uBAAuB;AAAA,IACvB,qBAAqB;AAAA;AAAA,EAEvB;AAAA,EACA;AAAA,IACE,SAAS;AAAA,EACX;AACF;AAEO,IAAM,cAAc,IAAI;AAAA,EAC7B;AAAA,EACA;AACF;AAEO,IAAM,mBAAmB,IAAI;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,IACE,SAAS;AAAA,EACX;AACF;AAEO,IAAM,yBAAyB,IAAI;AAAA,EACxC;AAAA,EACA;AACF;AAEO,IAAM,aAAa,IAAI;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,IACE,SAAS;AAAA,EACX;AACF;AAEO,IAAM,qBAAqB,IAAI;AAAA,EACpC;AAAA,EACA;AACF;AAEO,IAAM,gBAAgB,IAC1B,iBAAiB,EAAE,SAAS,4CAA4C,CAAC,EACzE;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,EACb;AAAA,EACA;AAAA,IACE,SAAS,CAAC,MAAM,EAAE;AAAA,EACpB;AACF;AAEK,IAAM,mBAAmB,IAC7B,iBAAiB;AAAA,EAChB,OAAO;AACT,CAAC,EACA;AAAA,EACC;AAAA,EACA;AAAA,EACA,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,MAAM,MAAM,MAAM,IAAI;AAAA,EAC/C;AAAA,IACE,SAAS,CAAC,MAAM,EAAE;AAAA,EACpB;AACF;AAEK,IAAM,mBAAmB,IAC7B,iBAAiB,EAAE,mBAAmB,6BAA6B,CAAC,EACpE;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,IACE,uBAAuB;AAAA,IACvB,qBAAqB;AAAA,IACrB,wCAAwC;AAAA,EAC1C;AAAA,EACA;AAAA,IACE,SAAS,CAAC,MAAM,EAAE;AAAA,EACpB;AACF;AAMK,IAAM,kBAAkB;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,qCAAqC;AAAA,EAChD;AAAA,EACA;AACF;;;AC9HA,OAAOC,YAAW;AAKX,IAAM,qBAAqB,YAAY;AAC5C,QAAMC,OAAM,uCAAuC;AACnD,QAAMA,OAAM,uCAAuC;AACnD,QAAM,6CAA6C;AACnD,QAAM,aAAaA,OAAM,OAAO,SAAS,CAAC,GAAG;AAC7C,QAAM,aAAaA,OAAM,OAAO,OAAO,CAAC,GAAG;AAC3C,QAAM,aAAaA,OAAM,OAAO,WAAW,CAAC,GAAG;AAC/C;AAAA,IACE,aAAaA,OAAM,OAAO,eAAe,CAAC,IAAIA,OAAM,KAAK,IAAI,CAAC,oBAAoBA,OAAM,KAAK,MAAM,CAAC;AAAA,EACtG;AACA,QAAM;AACN,QAAM,gBAAwC,MAAM,gBAAgB,MAAM;AAAA,IACxE,kBAAkB,CAAC;AAAA,IACnB,eAAe;AAAA,IACf,SAAS;AAAA,EACX,CAAC;AAED,QAAM;AAAA;AAAA;AAAA,CAAiE;AACvE;AAAA,IACE,0DAA0DA,OAAM,KAAK,KAAK,OAAO,CAAC;AAAA,EACpF;AACA;AAAA,IACE;AAAA,EACF;AACA;AAAA,IACE,mEAAmEA,OAAM,OAAO,MAAM,CAAC;AAAA,EACzF;AACA;AAAA,IACE,yDAAyDA,OAAM,OAAO,UAAU,CAAC;AAAA,EACnF;AACA;AAAA,IACE;AAAA,EACF;AACA,QAAM;AAEN,QAAM,MAAM,MAAM,uBAAuB,GAAG;AAE5C,MAAI,IAAI;AACN,kBAAc,mBAAmB;AAAA,EACnC;AAEA,QAAM;AACN,QAAMA,OAAM,KAAK,cAAc,CAAC;AAChC,QAAMA,OAAM,KAAK,cAAc,CAAC;AAChC,QAAM;AACN;AAAA,IACE;AAAA,EACF;AACA;AAAA,IACE,OAAOA,OAAM,OAAO,sBAAsB,CAAC;AAAA,EAC7C;AACA,QAAM;AACN;AAAA,IACE,mCAAmCA,OAAM,KAAK,cAAc,CAAC,WAAWA,OAAM,OAAO,iBAAiB,CAAC;AAAA,EACzG;AACA;AAAA,IACE,yBAAyBA,OAAM,OAAO,UAAU,CAAC;AAAA,EACnD;AACA,QAAM;AAEN,QAAM,SAAS,MAAM,mCAAmC,MAAM;AAE9D,MAAI,OAAO,aAAa;AACtB,eAAW,EAAE,UAAU,eAAe,SAAS,CAAC,EAAE,MAAM,OAAO,KAAK,CAAC,EAAE,CAAC;AAAA,EAC1E;AAEA,QAAM;AACN,QAAMA,OAAM,KAAK,0BAAmB,CAAC;AACrC,QAAMA,OAAM,KAAK,mBAAmB,CAAC;AACrC,QAAM;AACN;AAAA,IACE,wDAAwDA,OAAM,KAAK,WAAW,CAAC;AAAA,EACjF;AACF;;;AF9EA,SAAS,QAAAC,aAAY;AAErB,IAAM,WAAW,OAAO,QAA8B;AAEtD;AAEO,IAAM,mBAAmB,OAAO,QAA8B;AACnE,MAAI,CAAC,cAAc,GAAG;AACpB;AAAA,MACE,0DAAmDC,OAAM,KAAK,WAAW,CAAC;AAAA;AAAA,IAC5E;AACA,QAAI,OAAO,MAAMC,KAAI;AAAA,MACnB;AAAA,MACA;AAAA,IACF,EAAE;AACF,QAAI,KAAK,WAAW;AAClB,YAAM,mBAAmB;AACzB,UAAIC,OAAM,MAAMD,KAAI;AAAA,QAClB;AAAA,QACA;AAAA,MACF,EAAE;AAEF,UAAI,CAACC,KAAI,UAAU;AACjB,YAAI;AACJ,QAAAH,MAAK;AAAA,MACP;AAAA,IACF,OAAO;AACL,UAAI;AACJ,MAAAA,MAAK;AAAA,IACP;AAAA,EACF;AAEA,QAAM,SAAS,GAAG;AACpB;;;AGvCA,OAAO,sBAAsB;AAG7B,OAAOI,YAAW;AAQX,IAAM,WAAW,CAACC,SAAiB;AAAA,EACxC;AAAA,IACE,QAAQ;AAAA,IACR,SAAS;AAAA,EACX;AAAA,EACA;AAAA,IACE,QAAQ;AAAA,IACR,SAAS,UAAUA,IAAG,IAClB,GAAGC,OAAM,KAAK,IAAI,CAAC,IAAID,IAAG,IAAIC,OAAM,IAAI,KAAKA,OAAM,OAAO,SAAS,CAAC,IAAI,CAAC;AAAA;AAAA,EAAO,qBAAqBD,IAAG,KAAK,EAAE,KAC/G,GAAGC,OAAM,KAAK,IAAI,CAAC,MAAMA,OAAM,IAAI,cAAc,CAAC,MAAMA,OAAM,IAAI,KAAKA,OAAM,OAAO,SAAS,CAAC,IAAI,CAAC;AAAA;AAAA,yDAElDA,OAAM,KAAK,QAAQ,CAAC;AAAA;AAAA,EAE3E;AAAA,EACA,UAAUD,IAAG,IACT,CAAC,IACD;AAAA,IACE,QAAQ;AAAA,IACR,SAAS,OAAO,KAAK,oBAAoB,EACtC,IAAI,CAAC,MAAM;AACV,YAAM,OAAO,qBACX,CACF;AACA,aAAO,GAAGC,OAAM,KAAK,CAAC,CAAC,KAAKA,OAAM,IAAI,IAAI,CAAC;AAAA,IAC7C,CAAC,EACA,KAAK,IAAI;AAAA,EACd;AAAA,EACJ;AAAA,IACE,QAAQ,UAAUD,IAAG,IAAI,YAAY;AAAA,IACrC,YAAY,UAAUA,IAAG,IACrB;AAAA,MACE,GAAG,gBAAgBA,IAAG,EAAE,OAAO,CAAC,MAAM,EAAE,SAAS,KAAK;AAAA,MACtD,GAAG;AAAA,IACL,IACA;AAAA,EACN;AACF;AAEO,IAAM,YAAY,CAACA,SAA8B;AACtD,QAAM,QAAQ,iBAAiB,SAASA,IAAG,CAAC;AAC5C,UAAQ,IAAI,KAAK;AACnB;;;ACzCA,IAAM,CAAC,KAAK,GAAG,IAAI,WAAW;AAE9B,IAAI,CAAC,KAAK;AACR,YAAU;AACV,MAAI,IAAI,MAAM;AACZ,YAAQ,KAAK,CAAC;AAAA,EAChB,OAAO;AACL,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF,OAAO;AACL,MAAI,IAAI,MAAM;AACZ,cAAU,GAAG;AACb,YAAQ,KAAK,CAAC;AAAA,EAChB,OAAO;AACL,QAAI,UAAU,GAAG,GAAG;AAClB,YAAM,MAAM;AACZ,mBAAa,IAAI,QAAQ,UAAU,IAAI,UAAU,YAAY,QAAQ;AACrE,cAAQ,KAAK;AAAA,QACX,KAAK;AACH,gBAAM,aAAa,GAAuB;AAC1C;AAAA,QACF,KAAK;AACH,gBAAM,iBAAiB,GAA2B;AAClD;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AACF;","names":["path","path","existsSync","statSync","config","format","existsSync","statSync","chalk","chalk","config","chalk","ask","chalk","chalk","exit","chalk","ask","opt","chalk","cmd","chalk"]}